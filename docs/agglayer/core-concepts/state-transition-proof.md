# State Transition Proof

The **State Transition Proof** is Agglayer’s trust-validation process.  
Every time a chain submits a new state root, the proof system confirms two things:

1. The chain’s own state transitions are sound.  
2. Any cross-chain action (deposits, withdrawals, messages) matches the Agglayer’s records.

A state root is accepted only when both requirements pass.

## Two-Layer Verification Model

### 1. Internal State Transition Proof (Validity Proof)

* Verifies that all transactions in the block or epoch were executed correctly.  
* Implemented today with a **Full Execution Proof (FEP)** generated by the chain’s prover.  
* Other proof styles can be added without changing Agglayer logic.

### 2. Cross-Chain Verification (Aggchain Proof + Pessimistic Proof)

* Cross-checks every bridge operation against the **Unified Bridge**.  
* Combines:  
  * **Aggchain Proof** – confirms the chain’s view of bridge I/O.  
  * **Pessimistic Proof** – double-checks aggregate deposit and withdrawal balances.  

Only if both layers succeed does the Agglayer node certify the new state root.



## Default Chain Types

## ECDSA Verification

* A trusted sequencer signs each state root with its private key.  
* Verification = recover signer address and match it to the registered sequencer.  
* Pros: instant finality, minimal computation.  
* Cons: depends on the sequencer’s key remaining honest and online.

## Full Execution Proof (FEP)

* A zero-knowledge proof built with SP1 and PLONK.  
* Covers the full execution trace—transactions, state updates, bridge calls.  
* Trust-minimised; anyone can generate or verify the proof.  
* Supports optional optimistic mode for lower latency.

## Verification Methods : 

### ECDSA: Signature-Based Verification

The ECDSA (Elliptic Curve Digital Signature Algorithm) implementation is the original consensus mechanism used in Agglayer. In this system, a trusted sequencer (a designated address) acts as a security guard, signing off on state changes to ensure they are valid. When a chain wants to update its state or perform cross-chain operations, the trusted sequencer must verify and sign these changes using their private key. This signature serves as proof that the changes are legitimate and authorized. The system uses this signature to verify state transitions across three important data structures: the local exit tree (tracking cross-chain exits), the local balance tree (tracking token balances), and the nullifier tree (preventing double-spending).

```rust
// ECDSA Verification Code
pub fn verify(
    &self,
    l1_info_root: Digest,
    new_local_exit_root: Digest,
    commit_imported_bridge_exits: Digest,
) -> Result {
    // Verify only one ECDSA on the public inputs
    let sha256_fep_public_values = self.sha256_public_values();
    let signature_commitment = keccak256_combine([
        sha256_fep_public_values,
        new_local_exit_root.0,
        commit_imported_bridge_exits.0,
    ]);

    let recovered_signer = signature
        .recover_address_from_prehash(&B256::new(signature_commitment.0))
        .map_err(|_| ProofError::InvalidSignature)?;

    if recovered_signer != self.trusted_sequencer {
        return Err(ProofError::InvalidSigner {
            declared: self.trusted_sequencer,
            recovered: recovered_signer,
        });
    }

    Ok(())
}
```

### Validity Proof Verification

The Validity Proof(Full execution proof, aka fep in the Codebase) is a more advanced consensus mechanism that provides comprehensive verification of chain operations. Unlike the simpler ECDSA approach, Validity Proof is a proof system that verifies every aspect of a chain's state transition, in this case op-geth operations and verify bridge constraints. This system is particularly useful for chains that need to prove their entire state transition is valid, not just that it was authorized by a trusted party. Then Aggchain Proof will combine Validity Proof state transition proofs with bridge checks to ensure both internal chain operations and cross-chain transfers are valid.

```rust
// Validity Proof Verification Code
pub fn verify( 
    &self,
    l1_info_root: Digest,
    new_local_exit_root: Digest,
    commit_imported_bridge_exits: Digest,
) -> Result {
    // Verify l1 head
    self.verify_l1_head(l1_info_root)?;

    // Verify the FEP stark proof.
    {
        sp1_zkvm::lib::verify::verify_sp1_proof(
            &self.aggregation_vkey_hash.to_hash_u32(),
            &self.sha256_public_values().into(),
        );

        return Ok(());
    }
}
```

